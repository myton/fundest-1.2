/////////////////////////////////////////////////////////////////////////////////
// 
//  Fundamental matrix estimation from 2D point matches
//  Copyright (C) 2002 - 2011  Manolis Lourakis (lourakis **at** ics.forth.gr)
//  Institute of Computer Science, Foundation for Research & Technology - Hellas
//  Heraklion, Crete, Greece.
//
/////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>

#include "compiler.h"
#include "util.h"

#ifndef M_SQRT2
#define M_SQRT2  1.41421356237309504880  /* sqrt(2) */
#endif


/* Compute a normalizing transformation T mapping 'pts' to 'npts' as suggested by Hartley */
void fundest_normalize2DPts(double (*pts)[2], double (*npts)[2], int numpts, double T[9])
{
register int i;
double centx, centy;
double dist, scale;

	centx=centy=0.0;
	for(i=0; i<numpts; ++i){
		centx+=pts[i][0];
		centy+=pts[i][1];
	}

	centx/=(double)(numpts);
	centy/=(double)(numpts);

	dist=0.0;
	for(i=0; i<numpts; ++i){
    npts[i][0]=pts[i][0]-centx;
    npts[i][1]=pts[i][1]-centy;
		dist+=HYPOT2(npts[i][0], npts[i][1]);
	}

	dist/=(double)(numpts);
  scale=M_SQRT2/dist;
	
	for(i=0; i<numpts; ++i){
    npts[i][0]*=scale;
    npts[i][1]*=scale;
	}

	T[0]=scale; T[1]=0.0;   T[2]=-centx*scale;
	T[3]=0.0;   T[4]=scale; T[5]=-centy*scale;
	T[6]=0.0;   T[7]=0.0;   T[8]=1.0;
}


/*
 * Compute the inverse of a 3x3 matrix A into A1
 * using determinants
 *
 * returns 1 in case of error (e.g. A is singular),
 * 0 if successfull
 */
static int mat3x3Inverse(double a[9], double a1[9])
{
  /* Code generated by maple's codegen package and minimal editing */
  double t1, t11, t13, t14, t15, t17, t18, t2, t20, t21, t23, t26, t4, t5, t8, t9;
  {
    t1 = a[4];
    t2 = a[8];
    t4 = a[5];
    t5 = a[7];
    t8 = a[0];
    t9 = t8*t1;
    t11 = t8*t4;
    t13 = a[3];
    t14 = a[1];
    t15 = t13*t14;
    t17 = a[2];
    t18 = t13*t17;
    t20 = a[6];
    t21 = t20*t14;
    t23 = t20*t17;

    t26 = t9*t2-t11*t5-t15*t2+t18*t5+t21*t4-t23*t1;
    if (-DBL_MIN<=t26 && t26<=DBL_MIN){
      fprintf(stderr, "Zero determinant (%g) in mat3x3Inverse()\n", t26);
      return 1;
    }

    t26 = 1.0/t26;
    a1[0] = (t1*t2-t4*t5)*t26;
    a1[1] = -(t14*t2-t17*t5)*t26;
    a1[2] = (t14*t4-t17*t1)*t26;
    a1[3] = -(t13*t2-t4*t20)*t26;
    a1[4] = (t8*t2-t23)*t26;
    a1[5] = -(t11-t18)*t26;
    a1[6] = (t13*t5-t1*t20)*t26;
    a1[7] = -(t8*t5-t21)*t26;
    a1[8] = (t9-t15)*t26;

    return 0;
  }
}

/* C=A*B, for 3x3 matrices */
static void mat3x3Mult(double A[9], double B[9], double C[9])
{
  C[0]=A[0]*B[0] + A[1]*B[3] + A[2]*B[6];
  C[1]=A[0]*B[1] + A[1]*B[4] + A[2]*B[7];
  C[2]=A[0]*B[2] + A[1]*B[5] + A[2]*B[8];

  C[3]=A[3]*B[0] + A[4]*B[3] + A[5]*B[6];
  C[4]=A[3]*B[1] + A[4]*B[4] + A[5]*B[7];
  C[5]=A[3]*B[2] + A[4]*B[5] + A[5]*B[8];

  C[6]=A[6]*B[0] + A[7]*B[3] + A[8]*B[6];
  C[7]=A[6]*B[1] + A[7]*B[4] + A[8]*B[7];
  C[8]=A[6]*B[2] + A[7]*B[5] + A[8]*B[8];
}

/* nF=T2^-t * F * T1^-1  */
void fundest_normalizeF(double F[9], double T1[9], double T2[9], double nF[9])
{
double T1_1[9], T2_1[9], tmp[9], aux;

  mat3x3Inverse(T1, T1_1);
  mat3x3Inverse(T2, T2_1);

  /* transpose T2_1 in place */
  aux=T2_1[1]; T2_1[1]=T2_1[3]; T2_1[3]=aux;
  aux=T2_1[2]; T2_1[2]=T2_1[6]; T2_1[6]=aux;
  aux=T2_1[5]; T2_1[5]=T2_1[7]; T2_1[7]=aux;

  mat3x3Mult(T2_1, F, tmp);  /* tmp <-- T2^-t * FM       */
  mat3x3Mult(tmp, T1_1, nF); /* nF<-- T2^-t * FM * T1^-1 */
}

/* F = T2^t * nF * T1 */
void fundest_denormalizeF(double nF[9], double T1[9], double T2[9], double F[9])
{
double tmp[9], aux;

  /* transpose T2 in place */
  aux=T2[1]; T2[1]=T2[3]; T2[3]=aux;
  aux=T2[2]; T2[2]=T2[6]; T2[6]=aux;
  aux=T2[5]; T2[5]=T2[7]; T2[7]=aux;

  mat3x3Mult(T2, nF, tmp); /* tmp <-- T2^t * nF     */
  mat3x3Mult(tmp, T1, F);  /* F <-- T2^t * nF * T1 */

  /* undo transpose T2 */
  aux=T2[1]; T2[1]=T2[3]; T2[3]=aux;
  aux=T2[2]; T2[2]=T2[6]; T2[6]=aux;
  aux=T2[5]; T2[5]=T2[7]; T2[7]=aux;
}
